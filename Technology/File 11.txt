“Computing is evolving to higher levels” This chapter reviews how computing has evolved since it began, and what this means for “us all” who are building and using it.The first computer was conceived as a machine of cogs and gears (Figure 1.1) but only became practical in the 1950s and 60s with the invention of semi-conductors. In the 1970s, a hardware company called IBM (footnote 1) emerged as the computing leader. In the 1980s, however, software became increasingly important, and by the 1990s a software company called Microsoft (footnote 2) had become the computing frontline leader by giving ordinary people tools like word-processing. During the 1990s computing became more personal, until the World-Wide-Web turned Internet URLs into web site names that people could read (footnote 3). A company called Google (footnote 4) then offered the ultimate personal service, free access to the vast public library we call the Internet, and soon everyone's gateway to the web was the new computing leader. In the 2000s computing evolved yet again, to become a social medium as well as a personal tool. So now Facebook challenges Google, as Google challenged Microsoft, and as Microsoft challenged IBM.Yet to design a computer system one must define it, so what is computing? This deceptively simple question requires many answers because computing has re-invented itself every decade or so (Figure 1.2). What began as hardware became about software, then about users and is now about online communities. This chapter analyzes the evolution of computing as it impacts computing design. Courtesy of Jitze Couperus. Copyright: CC-Att-SA-2 (Creative Commons Attribution-ShareAlike 2.0 Unported). Figure 1.1: Charles Babbage (1791-1871) designed the first automatic computing engine. He invented computers but failed to build them. The first complete Babbage Engine was completed in London in 2002, 153 years after it was designed. Difference Engine No. 2, built faithfully to the original drawings, consists of 8,000 parts, weighs five tons, and measures 11 feet. Shown above is Serial Number 2, located in Silicon Valley at the Computer History Museum in Mountain View, California Courtesy of Jitze Couperus. Copyright: CC-Att-SA-2 (Creative Commons Attribution-ShareAlike 2.0 Unported). Courtesy of Jitze Couperus. Copyright: CC-Att-SA-2 (Creative Commons Attribution-ShareAlike 2.0 Unported).Figure: Details from Babbage's difference engine  Courtesy of Brian Whitworth and Adnan Ahmad. Copyright: CC-Att-SA-3 (Creative Commons Attribution-ShareAlike 3.0). Figure 1.2: The computing evolutionThe evolution of computing is approached here using Bertalanffy’s general systems theory (Bertalanffy, 1968). This theory is based on the observation of discipline isomorphisms, when different specialist fields discover the same abstract equation or law in different contexts, e.g. a social agreement measure that matches a biological diversity measure (Whitworth, 2006). Bertalanffy proposed a “science of sciences”, namely the study of systems in general, since sociologists study social systems, psychologists cognitive systems, computer scientists information systems, and engineers hardware systems. The isomorphisms of science are then general system rules that apply across disciplines.Applying general systems theory to the evolution of computing gives the computing levels shown in Figure 1.3, where a computing system can be studied as a mechanical system, a software system, a human system or a social system, by engineers, computer scientists, psychologists and sociologists respectively. Computing began at the mechanical level, added an information level (software), then a human level and finally a community level; it is an example of general system evolution. Courtesy of Brian Whitworth and Adnan Ahmad. Copyright: CC-Att-SA-3 (Creative Commons Attribution-ShareAlike 3.0). Figure 1.3: Computer system levelsTable 1.1 shows how different levels change not only the system type but also what is exchanged. So a physical system exchanges energy, a software system exchanges information, a human system exchanges meaning, and a community system exchanges memes (footnote 5). Each level of a system evolution is built on the previous, so that social computing emerges from personal computing, personal computing emerges from software, and software emerges from hardware. As computing evolves to higher system levels, so its design also changes, from technical to socio-technical design.Levels can clarify the often confusing terms of computing. In Figure 1.3, a technology is any tool that people build to use (footnote 6), e.g. a spear is a technology. Technology is designed and built by engineers. In contrast information technology (IT) is the application of hardware and software, with a user implied. Computer science (CS) (footnote 7) is then just about the software level, regardless of the hardware implementation. So information technology is not a sub-set of technology, nor is computer science a sub-set of engineering (because software is not part of hardware).Human computer interaction (HCI) is a person in front of a computer, a human plus IT system, with physical, informational and psychological levels. Just as IT is more than hardware, so HCI is more than IT because it includes a human level. HCI systems exchange meaning, while IT systems exchange information. The semantic web vision of Tim Berners-Lee, the founder of the World Wide Web — his “dream for the web” — was a recognition of the human level of computing.Today, computing supports online communities that, by the same logic, have hardware, software, personal and community levels. If the first two levels are technical and the last two social, the result is a socio-technical system (STS). If information technology design is computing built to hardware and software requirements, then socio-technical design is computing built to personal and community requirements as well. In socio-technical design, the new "user" of computing is the community (Whitworth, 2009a).Unfortunately, different disciplines use different terms for the same levels, e.g. the study of software can be called computer science or software engineering. The human level of computing is even more confusing: engineers use the term IT to refer to user applications; business prefers the term information systems (IS); education uses information communication technology (ICT); and health professionals invented the term informatics to meet their needs. Each defines itself apart, but in this pan-discipline view, all are just the human level of computing. This book uses the term HCI for consistency (footnote 8).LevelExchangeExamplesDesignCommunity(sociology)MemesNorms, culture, laws, zeitgeist, sanctions, rolesSTSPersonal(psychology)MeaningSemantics, attitudes, beliefs, feelings, ideasHCIInformation(computer science)InformationPrograms, data, bandwidth, memoryITMechanical(engineering)EnergyHardware, motherboard, telephone, FAXTechnologyTable 1.1: The levels of computing If all the Figure 1.3 levels are computing we must design computer products as both social and technical systems. Limiting computing to hardware (engineering) or software (computer science) denies its obvious evolution.Levels in computing are not system parts. To draw an analogy, a pilot flying an aircraft is one system with different levels, not a mechanical part (the aircraft) with a human part (the pilot). The physical level includes not just the aircraft body but also the pilot's body, as both have mass, volume, inertia etc. Likewise, the information level is not just the onboard computer, but also the neuronal processing of the pilot’s brain.The human level is the pilot, who from the sensations and perceptions of his or her brain generates meaning. To the pilot, the aircraft is an extension of his or her body, like extra hands or feet, and computer data is like extra eyes or ears. On a human level, the pilot is the actor, with the aircraft just a mechanical tool of the pilot’s will, so in an aerial conflict, the tactics of a piloted aircraft are different from a computer drone.To repeat, the mechanical level is not just the physical aircraft but also the pilot’s body, and the information level is all the processing, of both the brain and of onboard computers. Finally, an aircraft in a squadron may do things it would not do alone, e.g. expose itself as a decoy so that others can attack the enemy. Courtesy of Brian Whitworth and Adnan Ahmad. Copyright: CC-Att-SA-3 (Creative Commons Attribution-ShareAlike 3.0). Figure 1.4: Levels as higher abstractionsA level is now formally defined as a world view, a way of seeing reality that is complete and consistent in itself. So a computer on the mechanical level is all hardware but on an informational level it is all software. We cannot observe a program on a motherboard nor a hardware device in a data structure. Your mobile phone does not have separate hardware and software parts, but is hardware or software in toto, depending on how you view it.Hardware and software are therefore ways to view a computer system, not ways to divide it up. Hardware becomes software when we see computing in a different way. The switch is like someone swapping glasses to see the same thing close-up. Hardware and software are the different types of glasses we can use to view computing.Following this theory, all the disciplines of science are world views, like walking around an object to see it from different perspectives. We can then choose which view is most appropriate. For example, to describe World War II as a scientific history of atomic events would be ridiculously ineffective, as a political summary is the more appropriate view.As views, levels emerge from each other, as lower abstractions give higher ones (Figure 1.4). Information emerges from hardware options, meaning emerges from information flows, and communities emerge from common citizen meanings. Conversely, without physical choices there is no information, without information there is no meaning, and without meaning there is no community (footnote 9).A world view is:Essential. To view a world one needs a view perspective.Empirical. It arises from interaction with the world.Complete. It consistently describes a whole world.Subjective. We choose a view perspective, explicitly or not.Exclusive. You cannot view the world in two different ways at the same time, as you cannot sit in two places at once (footnote 10).Emergent. One world view can emerge from another.Note that a level as a view must be chosen before viewing, i.e. first pick a level, and then view.Levels affect design because how we see the world affects how we act in it; e.g. if we saw ultra-violet light, as bees do, previously dull flowers would become bright and so every flower shop would want to change its stock. Levels as higher ways to view a system are also new ways to operate and design the system. Hence new software protocols like Ethernet can improve network performance as much as new cables.Levels have also changed how business works in computing. When the software era arrived, hardware continued to evolve but hardware leaders like IBM no longer dominated computing unilaterally, as they had before. The software level changed business fortunes by changing what computing is. Selling software makes as much money as selling hardware, as the software changes more rapidly and needs to be replaced or updated more often. Web queries are even more volatile, so Google gave its service away for free and then sold advertising around it — it sold its services to those who sold theirs.As computing levels changed, so did the business model, as selling knowledge is not like selling software. Facebook is still working out its business model, because you cannot “sell” friendships as you do hardware and software. Yet Facebook now challenges Google because we relate to family and friends even more than we query knowledge — social exchange has as much trade potential as knowledge exchange.New ways to view computing thus affect how we design and build computing systems. Each level emerges to add to rather than replace earlier levels. As design requirements cumulate, socio-technical design includes hardware, software and human requirements, as well as community needs (Figure 1.5). Computing that appears to us as just hardware now has a social level; e.g. smart-phones are a communication medium as well as a hardware device. Computer design is inclusively evolving from engineering design to socio-technical design, to keep pace with computer evolution. Courtesy of Brian Whitworth and Adnan Ahmad. Copyright: CC-Att-SA-3 (Creative Commons Attribution-ShareAlike 3.0). Figure 1.5: Computing levels cumulateIt is worth reflecting on how the role of technology has changed in a few centuries. During the industrial revolution, technology was isolated from the needs of society; e.g. a village beside a factory belching smoke found its need for clean air threatened. The idea of socio-technology arose when technology was implemented with ethics as an after-thought.However, in the information revolution the social and technical merge into one. If social needs are not met online, there will be no online community, which means the technology fails. In socio-technical design, social needs as the higher level always come first. In the evolution of design, higher level requirements have a natural priority, as is now discussed.Hardware is any physical computer part, e.g. mouse, screen or case. It does not "cause" software, and nor is software a hardware output, in the way that physical systems have physical outputs. We create software by seeing information choices in physical events. Software needs hardware but the same code can run on a PC, Mac or mobile phone. An entity relationship diagram can work for any physical storage, whether disk, CD or USB, as data entities are not disk sectors. Software assumes some hardware but does not specify which hardware.If any part of a device acquires software, the whole system gets an information level; e.g. a computer is information technology even though its case is just hardware. We describe a system by its highest level, so if the operating system "hangs" (footnote 11) we say "the computer" crashed, even though the computer hardware is working fine. Rebooting fixes the software problem with no hardware change, so a software system can fail while the hardware still works perfectly.Conversely, a computer can fail as hardware but not software, if a chip overheats. Replace the hardware part and the computer works with no software change needed. Software can fail without hardware failing, and hardware can fail without software failing. A hardware update need not change the software, and a software update need not change the hardware. Equally, each level has its own knowledge base: if software fails we call a programmer, but if hardware fails we call an engineer.With this approach, design at one level is subject to higher level requirements. So software requirements can be met by hardware operations. For example, reading the information of a file takes longer if it is fragmented, as the drive head must jump between physically distant disk sectors. Defragmenting a disk improves software access by putting file data in adjacent physical sectors. Information access improves even though the physical drive read rate has not changed. Hardware actions can meet software goals, as database and network requirements are met by new hardware chip commands. The software goal, of better information throughput, also becomes the hardware goal, so physical chip design today is as much about caching and co-processing as it is about cycle rate. Hardware design is increasingly about meeting software requirements.As software emerged from hardware, it generated the new academic discipline of computer science. Computer scientists are not engineers, because they design algorithms not objects, but neither are they mathematicians, because their code runs on physical machines. Computer science is the “child” of mathematics and engineering, with the features of both but combined into a new discipline.HCI began in the personal computing or PC era. Adding people to the computing equation meant that getting the technology to work was only half the problem — the other half was getting people to use it. Web users who did not like a site just clicked on, and only web sites that got hits succeeded. Given equal functionality, users prefer a more usable product (Davis, 1989); e.g. Word replaced Word Perfect because users took a week to learn Word Perfect but picked up Word in a day. Just as computing had previously gained a software level, so it now gained a human level.Human computer interaction (HCI) is a person using IT, just as IT is software using hardware. As computer science emerged from a combination of mathematics and engineering, so HCI is emerging from psychology and computer science. If psychology is the study of people and IT the study of software and hardware, then HCI is the study of psychology as it applies to IT. It is the child of IT and psychology. It links CS to psychology as CS linked engineering to mathematics. This new meta-discipline applies psychological principles to computing design; e.g. Miller's paper on cognitive span suggests limiting computer menu choices to seven (Miller, 1956). The nature of people now defines the nature of computing; e.g. our many senses led to the multi-media trend.Even as HCI develops into a traditional academic discipline, computing has already moved on to add sociology to its list of paramours. Socio-technical systems use the social sciences in their design as HCI interfaces use psychology. STS is not part of HCI, nor is sociology part of psychology, because a society is more than the people in it; e.g. East and West Germany, with similar people, performed differently as communities, as do North and South Korea today. A society is not just a set of people. People who gather to view an event or customers shopping for bargains are an aggregate, not a community. They only become a community if they see themselves as one, i.e. the community level arises directly from personal level cognitions.Social systems can have a physical base or a technical base, so a socio-physical system is people socializing by physical means. Face-to-face friendships cross seamlessly to Facebook because the social level persists across physical and electronic architecture bases. Whether electronically or physically mediated, a social system is always people interacting with people. Electronic communication may be “virtual” but the people involved are real. Copyright status: Unknown (pending investigation). See section "Exceptions" in the copyright terms below.Figure 1.6: How computing disciplines ariseOnline communities work through people, who work through software that works through hardware. While sociology studies the social level alone, socio-technical design studies how social, human, information and hardware levels interact. A sociologist can no more design socio-technologies than a psychologist can design human-computer interfaces. STS and HCI need computer-sociologists and computer-psychologists. The complexity of modern computing arises from its discipline promiscuity (Figure 1.6).Before going on, we review the opposing theory of reductionism, which states that there is only one level, namely the physical level, and so everything can reduce to it. How has this worked in science?The reductionist dream is based on logical positivism (footnote 12), the idea that only the physical exists so all science must be expressed in physical terms. Yet when Shannon and Weaver defined information as a choice between physical options, the options were physical but the choosing was not (Shannon & Weaver, 1949). A message physically fixed in one way has by this definition zero information because the other ways it could have been fixed do not exist physically (footnote 13). It is logically true that hieroglyphics that cannot be read contain in themselves no information at all.If reader choices generate information, the data in a physical signal is unknown until it is deciphered. Data compression fits the same data in a physically smaller signal by encoding it more efficiently. It could not do this if information was fully defined by the physical message. The physical level is necessary for the information level but it is not sufficient. Conversely, information does not exist physically, as it cannot be touched or seen.So if the encoding is unknown, the information is undefined; e.g. an electronic pulse sent down a wire could be a bit, or a byte (an ASCII “1”), or, as the first word of a dictionary, say “aardvark”, be many bytes. The information a message conveys depends on the decoding process; e.g. every 10th letter of this text gives an entirely new (and nonsensical) message.One response to reductionism is mathematical realism, that mathematical laws are real even if they are not concrete (Penrose, 2005). Mathematics is a science because its constructs are logically correct, not because they are physical. That an equation is later physically useful is not the cause of its reality. Reality is now a consensual construct, with physicality just one option. Likewise in psychology Skinner’s attempt to reduce all cognitions to physical behaviour did not work and has been replaced by cognitive realism, that cognitions are also real.The acceptance of mathematical and cognitive constructs does not deny science, because science only requires that theory constructs be validated empirically, i.e. by a physical measure (footnote 14), not that they be physical. For example, fear as a cognitive construct can be measured by heart rate, pupil dilation, blood pressure, a questionnaire, etc.Even physics cannot reduce its theories to pure physicality, as quantum theory implies a primordial non-physical (footnote 15) quantum level of reality below the physical (Whitworth, 2011). In physics, reductionism gave a clockwork universe where each state perfectly defined the next, as in a computer. Quantum physics flatly denied this, as random quantum events by definition are explained by no physical history. The quantum world cannot be reduced to physical events (footnote 16). Either quantum theory is wrong, or reductionism does not work. If all science were physical, all science would be physics, which it is not.A reductionist philosophy that has failed in science in general is hardly a good base for a computing model. If the physical level were sufficient alone, there would be no choices and so no information, i.e. reductionism denies information science. As the great 18th century German philosopher Kant argued long ago, we see an object, or phenomenon, as a view, but don’t see the thing in itself (Kant, 1781/2002) (footnote 17). Following Kant’s model, the different disciplines of science are just different ways to view the same unspecified reality. Levels return the observer to science, as quantum theory's paradoxes demand.Currently, sociology sees individuals as conduits of meaning that reflect external social structures, and so psychological, biological, and physical views are the faulty reductionism of social realities. In this social determinism, society writes social agendas, such as communism or capitalism, upon individual tabulae rasae (blank slates). Yet this just replaces the determinism of fields like biology (Wilson, 1975) and psychology (Skinner, 1948) by another form of determinism.By contrast, in the general system model of computing shown in Figure 1.5, each level emerges from the previous. So if all individual thoughts were erased, society would also cease to exist as surely as if all its citizens had vanished physically. Sociology assumes psychology, which has led to attempts to re-attach it to its psychological roots, e.g. Bourdieu’s habitus references individual cognitions of the social environment and Gidden's mental frames underlie social life (Bone, 2005). The top-down return of sociology to its source matches an equally vibrant bottom-up movement in computing, which has long seen itself as more than hardware and software (Boulding, 1956).The evolution of computing implies a requirements hierarchy (Figure 1.7). If the hardware works, then software becomes the priority; if the software works, then user needs become important; and if user needs are fulfilled, then social requirements arise. As one level's issues are met, those of the next appear, just as climbing one hill reveals another. As hardware over-heating problems are solved, software data locking problems arise. As software response times improve, user response times become the issue. Companies like Google and E-bay still seek customer satisfaction, but customers in crowds also have community needs like fairness, i.e. higher system levels invoke higher requirements.In general, the highest system level defines its success; e.g. social networks need a community to succeed. If no community forms, it does not matter how easy to use, fast or reliable the software is. Lower levels become necessary to avoid failure but not sufficient to define success.LevelRequirementsErrorsCommunityReduce community overload, clashes. Increase productivity, synergy, fairness, freedom, privacy, transparency.Unfairness, slavery, selfishness, apathy, corruption, lack of privacy.PersonalReduce cognitive overload, clashes. Increase meaning transfer efficiency.User misunderstands, gives up, is distracted, or enters wrong data.InformationReduce information overload, clashes. Increase data processing, storage, or transferefficiencyProcessing hangs, data storage full, network overload, data conflicts.MechanicalReduce physical heat or force overload. Increase heat or force efficiency.Overheating, mechanical fractures or breaks, heat leakage, jamsTable 1.2: Computing errors by system level Conversely, any level can cause failure; it does not matter how strong the community is if the hardware fails, the software crashes or the interface is unusable. An STS fails if its hardware fails, if its program crashes or if users cannot figure it out. Hardware, software, personal and community failures are all computing errors (Table 1.2). The common feature is that the system fails to perform and in evolution what does not perform, does not survive (footnote 18).Each level emerges from the previous but fails differently:Hardware systems based on physicalenergy exchange fail from problems like overheating.Software systems based on information exchange fail from problems like infinite loops.HCI systems based on meaning exchange fail from problems like misunderstanding or information overload.Socio-technical systems based on normative meme exchange fail from problems like mistrust, unfairness and injustice.Computing as technology fails for technical reasons but, as socio-technology, also fails for social reasons. Courtesy of Brian Whitworth and Adnan Ahmad. Copyright: CC-Att-SA-3 (Creative Commons Attribution-ShareAlike 3.0). Figure 1.7: The computing requirements hierarchyTechnology is hard, but society is soft. That the soft should direct the hard seems counter-intuitive, but trees grow at their soft tips more than at their hard base. As a tree trunk does not direct its expanding canopy, so today's social computing advances were undreamt of by its engineering base. Today’s technology designers will find the future of design in level combinations.The general system concept of levels makes system design complex, as the design requirements of one level can “flow down” to those below it. This gives us a variety of design fields, as seen below. Courtesy of Ocrho. Copyright: pd (Public Domain (information that is common property and contains no original authorship)). Figure 1.8.A: Apple controls meet human requirements. Courtesy of Unknown author. Copyright: pd (Public Domain (information that is common property and contains no original authorship)). Figure 1.8.B: TV controls meet engineering requirements(footnote 19)Ergonomics designs safe and comfortable machines for people. Applying biological needs, such as avoiding posture and eye-strain, to technology design merges biology and engineering.Object design applies psychological needs to technology in the same way (Norman, 1990): e.g. a door's design affects whether it is pushed or pulled. An affordance is a physical object feature that cues its human use, as buttons cue pressing. Physical systems designed with affordances based on human requirements perform better. In World War II, aircraft crashed until engineers designed cockpit controls with the cognitive needs of pilots in mind, as follows (with computing examples):Put the control by the thing controlled, e.g. a handle on a door (context menus).Let the control “cue” the required action, e.g. a joystick (a 3D screen button).Make the action/result link intuitive, e.g. press a joystick forward to go down, (press a button down to turn on).Provide continuous feedback, e.g. an altimeter, (a web site breadcrumbs line).Reduce mode channels, e.g. altimeter readings, (avoid edit and zoom mode confusions).Use alternate sensory channels, e.g. warning sounds, (error beeps).Let pilots "play", e.g. flight simulators, (a system sandbox).Human computer interaction applies psychological requirements to screen design. Usable interfaces respect cognitive principles, e.g. by the nature of human attention, users do not usually read the entire screen. HCI turns psychological needs into IT designs as architecture turns buyer needs into house designs. Compare Steve Jobs' IPod to a television remote (Figure 1.8). Both are controls (footnote 20) but one is a cool tool and the other a mass of buttons. If one was designed to engineering requirements and the other to HCI requirements, which performs better?Fashion is the social requirement to look good applied to wearable object design. In computing, a mobile phone can be a fashion accessory, just like a hat or handbag. Its role is to impress, not just to function. Aesthetic criteria apply when people buy mobile phones to be trendy or fashionable, so colour can be as important as battery life in mobile phone design.Socio-technology is information technology meeting social requirements. Anyone online can see its power, but most academics see it as an aspect of their specialty, rather than a new multi-discipline in its own right. As computing evolved a social level, social requirements became part of computing design (Sanders & McCormick, 1993).Multi-disciplinary fields cannot, by their nature, be reduced to component discipline specialties; e.g. sociologists study society not technology, and technologists study technology not society, so neither can address socio-technical design — how social needs impact technical design. Table 1.3 summarizes design fields by level combination.DesignRequirementsTargetExamplesSTSSocialITWikipedia, YouTube, E-bayFashionSocialPhysical AccessoryMobile phone as an accessoryHCIPsychologicalITFraming, border contrast, richnessDesignPsychologicalTechnologyKeyboard, mouseErgonomicsBiologicalTechnologyAdjustable height screenTable 1.3: Design fields by target and requirement levels In Figure 1.9, higher level requirements flow down to lower level design, giving a higher affects lower design principle. Higher levels direct lower ones to improve system performance. Levels cumulate, so the requirements of each level flow down to those below, e.g. community agreement gives normative influence at the citizen level, laws at the informational level, and cultural events at the physical level. The same applies online, as online communities make demands of Netizens (footnote 21) as well as software. STS design therefore is about having it all: reliable devices, efficient code, intuitive interfaces and sustainable communities. Copyright status: Unknown (pending investigation). See section "Exceptions" in the copyright terms below.Figure 1.9: Computing requirements cumulateNote that the social level is open ended, as social groups form higher social groups, e.g. in physical society, over thousands of years, families formed tribes, tribes formed city states, city-states formed nations and nations formed nations of nations, each with more complex social structures (Diamond, 1998). How social units combine into higher social units (footnote 22) with new requirements is discussed further in Chapter 5.So it is naive to think that friend systems like Facebook are the last step, that social computing will stop at a social unit size of two. Beyond friends are tribes, cities, city-states, nations and meta-nations like the USA. Since we have a friend but belong to a community, the rules also change. With the world population at seven billion and growing, Facebook's over 900 million active accounts are just the beginning. The future is computer support not just for friends, but also for families, tribes, nations and even global humanity.For example, imagine a group browser, designed for many not just one, so that people can browse the Internet in groups, discussing as they go. Instead of a physical tour bus there is an informational tour browser. It can have a “driver” who comments along the way: “This site shows how the Internet began ...” . Or members could take turns to host the next site, showing what they like. The possibilities of social computing are just beginning.Figure 1.10 shows how computing evolved through the four stages of hardware, software, people and community. At each stage, a new specialty joined computing, but pure engineers still see only mechanics, pure computer scientists only information, pure psychologists only human constructs, and pure sociologists only social structures. Yet the multi-discipline of computing as a whole is not pure, because purity is not the future. It is more akin to a bazaar than a cathedral, as computer practitioners understand (Raymond, 1999). Courtesy of Brian Whitworth and Adnan Ahmad. Copyright: CC-Att-SA-3 (Creative Commons Attribution-ShareAlike 3.0). Figure 1.10: The four stages of computing(footnote 23)In academia, computing struggles because academics must specialize to get publications, grants and promotions (Whitworth & Friedman, 2009), so discipline specialties guard their knowledge in journal castles with jargon walls. Like medieval fiefdoms, they hold hostage knowledge that by its nature should be free. The divide and conquer approach of reductionism does not allow computing to prosper as an academic multi-discipline.In practice, however, computing is thriving. Every day more people use computers to do more things in more ways, so engineering, computer science, health (footnote 24), business, psychology, mathematics and education compete for the computing crown (footnote 25). The kingdom of research into computing is weak because it is a realm divided. It will get weaker if music, art, journalism, architecture etc. also add outposts. Computing researchers are scattered over the academic landscape like the tribes of Israel, some in engineering, some in computer science, some in health, etc. Yet we are one.The flower of computing is the fruit of many disciplines but it belongs to none. It is a new multi-discipline in itself (Figure 1.11). For it to bear research fruit, its discipline parents must release it. Using different terms, models and theories for the same subject just invites confusion. Universities that compartmentalize computing research into isolated discipline groups deny its multi-disciplinary future. As modern societies federate states and nations, so the future of computing is as a federation of disciplines. Until computing research unifies, it will remain as it is now — a decade behind computing practice. Courtesy of Brian Whitworth and Adnan Ahmad. Copyright: CC-Att-SA-3 (Creative Commons Attribution-ShareAlike 3.0). Figure 1.11: The flower of computingThe following questions are designed to encourage thinking on the chapter and exploring socio-technical cases from the Internet. If you are reading this chapter in a class - either at university or commercial – the questions might be discussed in class first, and then students can choose questions to research in pairs and report back to the next class.How has computing evolved since it began? Is it just faster machines and better software? What is the role of hardware companies like IBM and Intel in modern computing?How has the computing business model changed as it evolved? Why does selling software make more money than selling hardware? Can selling knowledge make even more money? What about selling friendships? Can one sell communities?Is a kitchen table a technology? Is a law a technology? Is an equation a technology? Is a computer program a technology? Is an information technology (IT) system a technology? Is a person an information technology? Is an HCI system (person plus computer) an information technology? What, exactly, is not a technology?Is any set of people a community? How do people form a community? Is a socio-technical system (an online community) any set of HCI systems? How do HCI systems form an online community?Is computer science part of engineering or of mathematics? Is human computer interaction (HCI) part of engineering, computer science or psychology? Is socio-technology part of engineering, computer science, psychology or one of the social sciences? (footnote 26)In an aircraft, is the pilot a person, a processor, or a physical object? Can one consistently divide the aircraft into human, computer and mechanical parts? How can one see it?What is the reductionist dream? How did it work out in physics? Does it recognize computer science? How did it challenge psychology? Has it worked out in any discipline?How much information does a physical book, that is fixed in one way, by definition, have? If we say a book "contains" information, what is assumed? How is a book's information generated? Can the same physical book "contain" different information for different people? Give an example.If information is physical, how can data compression put the same information in a physically smaller signal? If information is not physical, how does data compression work? Can we encode more than one semantic stream into one physical message? Give an example.Is a bit a physical "thing"? Can you see or touch a bit? If a signal wire sends a physical "on" value, is that always a bit? If a bit is not physical, can it exist without physicality? How can a bit require physicality but not itself be physical? What creates information, if it is not the mechanical signal?Is information concrete? If we cannot see information physically, is the study of information a science? Explain. Are cognitions concrete? If we cannot see cognitions physically, is the study of cognitions (psychology) a science? Explain. What separates science from imagination if it can use non-physical constructs in its theories?Give three examples of other animal species who sense the world differently from us. If we saw the world as they do, would it change what we do? Explain how seeing a system differently can change how it is designed. Give examples from computing.If a $1 CD with a $1,000 software application on it is insured, what do you get if it is destroyed? Can you insure something that is not physical? Give current examples.Is a "mouse error" a hardware, software or HCI problem? Can a mouse's hardware affect its software performance? Can it affect its HCI performance? Can mouse software affect HCI performance? Give examples in each case. If a wireless mouse costs more and is less reliable, how is it better?Give three examples of a human requirement giving an IT design heuristic. This is HCI. Give three examples of a community requirement giving an IT design heuristic. This is STS.Explain the difference between a hardware error, a software error, a user error and a community error, with examples. What is the common factor here?What is an application sandbox? What human requirement does it satisfy? Show an online example.Distinguish between a personal requirement and community requirement in computing. Relate to how STS and HCI differ and how socio-technology and sociology differ. Are sociologists qualified to design socio-technical systems? What about HCI experts?What in general do people do if their needs are not met in a physical situation? What do users do if their needs are not met online? Is there a difference? Why or why not? What do citizens of a physical community do if it does not meet their needs? What about an online community? Again, is there a difference? Give specific examples to illustrate.According to Norman, what is ergonomics? What is the difference between ergonomics and HCI? What is the difference between HCI and STS?Give examples of the following: Hardware meeting engineering requirements. Hardware meeting Computer Science requirements. Software meeting CS requirements. Hardware meeting psychology requirements. Software meeting psychology requirements. People meeting psychology requirements. Hardware meeting community requirements. Software meeting community requirements. People meeting community requirements. Communities meeting their own requirements. Which of these are computing design?Why is an IPod so different from TV or video controls? Which is better and why? Why has TV remote design changed so little in decades? If TV and the Internet compete for the hearts and minds of viewers, which one will win?How does an online friend differ from a physical friend? Can friendships transcend physical and electronic interaction architectures? Give examples. How is this possible?How available are academic papers? Pick 10 important journal papers and using non-university browsing, try to access them for free. How many author home pages offer their own papers for free download? Should journals be able to copyright papers they neither wrote nor paid for?Why do universities divide computing research across many disciplines? What is a cross-discipline? What past cross-disciplines became disciplines. Why is computing a cross-discipline?
            With 126,454 graduates, the Interaction Design Foundation is the biggest
            online design school globally. We were founded in 2002.
        
    Reach us at hello@interaction-design.org
    or through our
    online contact form.

    Have questions? Check our frequently asked questions.

    Join 288,589 designers and get
    weekly inspiration and design tips in your inbox.

            Enjoy unlimited downloads of our literature. Our online textbooks are written by 100+ leading designers,
            bestselling authors and Ivy League professors.
        
            Download our free ebook The Basics of User Experience Design
            to learn about core concepts of UX design.
        
            In 9 chapters, we’ll cover: conducting user interviews,
            design thinking, interaction design, mobile UX design,
            usability, UX research, and many more!
        
            Download our free ebook The Basics of User Experience Design
            to learn about core concepts of UX design.
        
            In 9 chapters, we’ll cover: conducting user interviews,
            design thinking, interaction design, mobile UX design,
            usability, UX research, and many more!
        